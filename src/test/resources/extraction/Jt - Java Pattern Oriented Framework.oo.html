<?xml version="1.0"?>
<html xmlns="http://www.w3.org/1999/xhtml"><body>

		


	    
	
		
	

    
	
		<ul><li>
				<a href="http://www.ibm.com/developerworks/"><img src="//dw1.s81c.com/developerworks/i/mf/dwn-dw-wordmark.png" width="225" height="28" /></a>
			</li></ul>
		
		
		
  


	    

 

	 
	
		
      <ul><li><a href="http://www.ibm.com/developerworks/">developerWorks</a></li><li><a href="http://www.ibm.com/developerworks/topics/">Technical topics</a></li><li><a href="http://www.ibm.com/developerworks/webservices/">SOA and web services</a></li><li><a href="http://www.ibm.com/developerworks/webservices/library/">Technical library</a></li></ul>
		
			
			<h1>Jt - Java Pattern Oriented Framework</h1><p><em>An application of the Messaging Design Pattern</em></p>
	
	 
	
	
		
		<p>Jt is a design pattern framework for the rapid implementation of Java applications. The framework architecture is based on a messaging design pattern which is utilized to implement many well-known design patterns, in addition to SOA and ESB capabilities.</p>
		<p>

			<a href="ws-designpattern-pdf.pdf">PDF</a> (235 KB) |
			
		</p>
		    Share:
		
		
			<p><a href="#authorN10024">Al Galvis</a> (<a href="mailto:jtowner@dev.java.net?subject=Jt - Java Pattern Oriented Framework">jtowner@dev.java.net</a>), Consultant, 				IBM</p>
<p><a href="#close">Close [x]</a></p>
<p>
Al Galvis have had several roles over a period of many years in the computer industry. Roles include Computer Science Professor, Computer Scientist at research facilities and roles as a technical consultant and architect for
several major corporations.</p><br /><br />
			<p>27 May 2010</p>
			
				<p>Also available in <a href="http://www.ibm.com/developerworks/jp/webservices/library/ws-designpattern/">Japanese</a></p>

			<ul><li><a href="#toggle"><img src="//www.ibm.com/i/c.gif" /></a>Table of contents<ul><li><a href="#N10038">Overview</a></li><li><a href="#N1004F">Messaging Design Pattern
    (MDP)</a></li><li><a href="#N100B1">Design Pattern
    implementation</a></li><li><a href="#N100DD">Web Services and transparent
    access</a></li><li><a href="#N1011E">Framework Security </a></li><li><a href="#N10128">Asynchronous messaging,
       two-way messaging and multithreading</a></li><li><a href="#N10132">Performance,
       scalability and fault-tolerant considerations</a></li><li><a href="#N1013C">Enterprise Service Bus (ESB)
    capabilities</a></li><li><a href="#resources">Resources</a></li><li><a href="#icomments">Comments</a></li></ul></li></ul>
		
	
	


















<h2>Overview</h2><p>Jt is a Design Pattern Framework for the rapid implementation of Java applications. Jt has been utilized in several large mission critical systems. The framework addresses the following goals:</p><ol><li>The framework architecture is based on a messaging design pattern: framework
    components are able to interchange information and perform computations by sending,
    receiving and processing messages. A messaging API provides simplicity, strong encapsulation and loose coupling; framework components can be interchangeably plugged into complex framework applications using a "lego/messaging" architecture. Framework messages can be processed synchronously or asynchronously. The framework takes full advantage of the power and simplicity of the messaging design pattern/API.</li><li>The design pattern framework uses messaging to implement and/or facilitate the implementation of well-known design patterns like Gang Of Four design patterns (GoF) and J2EE Design patterns. The framework itself is conceived and implemented, from the ground up, based on design patterns. The framework also facilitates and accelerates the implementation of applications based on design patterns.</li><li>The framework lego/messaging architecture provides transparent and secure access to remote components: remote framework objects are treated as local objects. Design patterns implemented by the framework (messaging, adapters, remote proxies and facades) make this possible by hiding the complexities associated with remote APIs. Built-in components for message encryption and authentication are provided. </li><li>The framework provides transparent integration with other technologies via framework
adapters, proxies and the implementation of related design patterns. These technologies include BPM,  Data Access Object implementations (DAO), Model View Controller implementations (MVC), EJBs, JSP, AJAX, ESB,  JMS, XML, REST and Web Services. </li><li>The framework is designed to be lightweight and fast (low overhead/small footprint).</li><li>The framework messaging/lego architecture improves and simplifies design/development efforts. There is a tight correspondence between UML design diagrams and the framework messaging based applications and components needed for the implementation. The framework provides wizards and automated capabilities for generating framework applications. Framework components can be easily added to BPM/BPEL process diagrams. In future versions of the framework, it should be possible for application modules to be generated directly from the UML design diagrams.  This goal is still work in progress.</li><li>The framework messaging architecture facilitates testing and debugging efforts. The framework provides capabilities for testing components as independent units by sending messages to the component and verifying the expected reply messages.</li></ol><hr /><p><a href="#ibm-content">Back to top</a></p><h2>Messaging Design Pattern
    (MDP)</h2><p><strong>Intent</strong>: The messaging design pattern allows the interchange of information (i.e. messages) between components and applications. </p><p><strong>Motivations (forces)</strong>:  This design pattern can be applied to solve a great variety of problems in many diverse scenarios. A messaging paradigm is widely used in nature and the real world. Messages are interchanged all around us. Entities are constantly sending, receiving and processing messages. Human beings for instance:  when we watch TV, listen to music, talk over the phone, or communicate via the internet. Right now, you are reading this written message. Since computer applications seek to model the real world, it is only natural to design and write applications using a messaging approach. We can argue that this approach provides a more complete and accurate representation (i.e. model) of the real world. As a consequence, software engineering processes are significantly improved by the use of the messaging design pattern.</p><p><strong>Participants:</strong></p><p>Message Sender: Component that sends the message.</p><p>Message Recipient (Receiver): Component that receives the input message and may produce a reply (output message) after processing it.  The input message, general in nature, may contain any type of information. The component may be instructed to perform computations based on the input message. </p><p>Messenger: Intermediary that transfers the message from the sender to the recipient. The sender and the recipient don’t need to be concerned about how the message is transferred (communication protocol, message format, encryption/security mechanism, etc.) and the transformations performed on the message along the way. This is the messenger’s purpose and responsibility. Similar to the real world, it is often the case that the messenger is not required. The message can be sent directly to the message recipient. Several modes of communication are possible: synchronous, asynchronous and two-way messaging.</p><p>Message: any piece of information (i.e. data) that needs to be interchanged between
    sender and recipient. Two messages are usually involved: input message and output
    message (or reply message). The reply message is not required.</p><h5>Figure 1. Messaging Interface</h5><img src="JtInterfaceClass.jpg" width="137" /><h5>Figure 2. Messaging Design Pattern (synchronous mode)</h5><img src="JtInterface1.gif" width="580" /><h5>Figure 3. Messaging Design Pattern (synchronous mode without messenger involved)</h5><img src="JtInterface.gif" width="304" /><p><strong>Consequences:</strong></p><ul><li>Encapsulation. The messaging design pattern maximizes encapsulation. Each component is a self-contained/independent unit. The only mechanism of communication with other components and applications is via messaging.</li><li>Decoupling. MDP minimizes coupling. Again each component is a self-contained unit that can perform independently from the rest of the system.</li><li>Reusability. MDP improves reusability. This is similar to the building blocks in a “Lego” set. Very complex models can be built based on simple pieces that share a simple way of interconnecting them (i.e. common interface). The power of the approach is derived from the number of combinations in which these toy pieces can be assembled. Components that use the messaging design pattern can be interchangeably plugged into complex applications. The components can be assembled in a limitless variety of configurations. The user of a component only needs to know the input/output messages that the component handles. Applications are also able to reuse components from other applications at the component level: a single component can be extracted from another application, provided that the messaging design pattern is being used. </li><li>QA/Testing process. MDP facilitates testing and debugging efforts. Components are tested as independent units by sending messages to the component and verifying the expected reply messages (black-box testing). In general, unit testing can be performed via a testing harness. No need to include testing code inside the component code which can be time consuming and lead to the unexpected introduction of software defects. </li><li>Design process. MDP improves and simplifies the design process. The bulk of the design work becomes defining the set of components needed to meet the system requirements and the input/output messages that each component needs to handle. There is a tight correspondence between UML design diagrams and the components needed for the implementation. Since all components share the same messaging interface, they can also be easily added to BPM/BPEL diagrams. As mentioned earlier, this is similar to building blocks that can be reused and connected in many different ways.</li><li>Development process. Since each component that relies on messaging is self-contained, a large team of people can cooperate in the development effort without stepping on each other's code/work. In the ideal situation, responsibility for one component/package can be given to an individual. The rest of the team only needs to know the input/output messages that someone else’s component is designed to handle. No need to change someone else’s code. The need for creating, maintaining and merging several versions of the code is also minimized or eliminated. Testing/QA engineers can do their testing independently via a testing harness. In general, there is no need to add testing code. </li><li>Logging and Debugging. Since all the components use the same messaging interface, messages can be logged automatically. This minimizes the need for print/logging statements inside the code which can be time consuming and error-prone. By taking a look at the messages being logged, the user is usually able to quickly track down the message/component that is causing the problem (with minimum or no extra effort). </li><li>Speed of development and cost. Because of all the reasons outlined above, the messaging design pattern is able to substantially improve the speed of development and reduce cost. </li><li>Quality and software maintenance. Quality and software maintenance efforts are also improved as a result of the all of the above.</li><li>In order to take full advantage of this design pattern, people need to think in terms of messaging when they model, design and build software applications: independent entities (i.e. components) interchanging messages among each other.  This may require learning time and training. Although a messaging approach is natural, intuitive, and consistent with the real world, traditional approaches are based on libraries and method/procedure invocation (both local and remote).</li><li>MDP behaves like a state machine. Therefore it can be extended to provide fault-tolerant capabilities in a very natural and intuitive fashion by replicating components and coordinating their interaction via consensus algorithms. Adding fault-tolerant characteristics to a program that doesn’t use MDP is, in general, a difficult undertaking. </li></ul><h3>Implementation and Code
    Examples:</h3><p>The messaging design pattern is implemented using the Jt messaging interface (JtInterface). This interface consists of a single method:</p><h5>Listing 1. Messaging Interface</h5><pre>public interface JtInterface  {

/**
  * Jt messaging interface used for the implementation
  * of the messaging design pattern.
  * Process an input message and return a reply (output message). 
  */

  Object processMessage (Object message); 
}</pre><p>The messaging interface (JtInterface) is simple but powerful. The simplicity of this interface can be deceiving. One method is all that is needed! It acts as a universal messaging interface that applies to remote and local framework components. This interface handles any type of message (Object class). Although a Java implementation is presented here, MDP and the associated framework can be implemented using any computer language or technology. </p><hr /><p><a href="#ibm-content">Back to top</a></p><h2>Design Pattern
    implementation</h2><p>As stated earlier, MDP has been used to implement and/or facilitate the implementation of other well-known design patterns like Gang of Four design patterns (GoF), DAO, J2EE Design patterns, etc. A couple of patterns will be used to illustrate how this is accomplished. The same concepts apply to the implementation of many others. The Jt framework employs these patterns for the implementation of advanced capabilities. </p><h3>Proxy</h3><p>The messaging design pattern facilitates the implementation of Proxy. Under the messaging paradigm, Proxy is mainly responsible for forwarding the input message to the real subject. </p><h5>Figure 4. MDP implementation of Proxy</h5><img src="JtProxy.gif" width="580" /><h3>Adapter</h3><p>The messaging design pattern facilitates the implementation of Adapter. The main purpose of Adapter becomes the transformation of messages between Sender and Receiver so that these components can be interconnected.  </p><h5>Figure 5. MDP implementation of Adapter</h5><img src="JtAdapter.gif" width="580" /><hr /><p><a href="#ibm-content">Back to top</a></p><h2>Web Services and transparent
    access</h2><p>Notice that MDP sender and receiver don't need to be running on the same host. Messages
    can be sent to remote components. MDP doesn't impose limitations in this regard. Using a real-world analogy, you can communicate with a friend across the room or thousands of miles away via a phone/internet conversation. MDP is able to handle all these scenarios. You and your friend don’t need to be concerned as to how your conversation is transmitted (technologies, communication protocols, security mechanisms, etc). As it should be, all of this is transparent to you.</p><p>As Figure 6 shows, the messaging design pattern and several of the other design patterns discussed earlier can be combined to implement access to remote components. MDP is able to provide transparent and secure access to remote components/services regardless of the protocol and communication technology being used: remote component are treated as local components. Messages can be transferred via web services, REST, EJBs, RMI, HTTP, Sockets, SSL or any similar communication interface. The design patterns discussed above make this possible by hiding the complexities associated with remote APIs. </p><h5>Figure 6. MDP transparent access to distributed components/services</h5><img src="JtRemoteProxy1.gif" width="580" /><p>For clarity sake the messenger component and the intrinsic <code>processMessage()</code> method have
    been removed from this and the following UML diagrams. Although asynchronous messaging
    is supported, only synchronous messaging is shown.</p><ol><li>Proxy: the message is sent to the remote component via its proxy.</li><li>Remote Adapter : adapter responsible for interfacing with the remote API by converting the messages.</li><li>Façade: forward the message to the appropriate remote component. It usually provides security capabilities as well.</li></ol><p>Going back to our real-world analogy, the framework maintained by the phone company
       will require some sort of <em>registry</em> (phone book) so that other participants can be located. Each entity will have associated a phone number or ID. A simple naming mechanism is all that is required. In some cases we may need to provide a city code and/or country code.  The postal service and your internet service provider also use a relatively simple naming scheme. </p><p>Other service providers take advantage of the framework and use custom
        <em>authentication/authorization</em> mechanisms. Your banking institution, for
        instance, makes use of the phone system and has <em>Access Management</em> mechanisms for authorization and authentication purposes. We are required to provide some piece of information to authenticate our identity before being granted access to an account. </p><p>The additional framework components required are not too different from the ones outline above. The façade component is usually responsible for security (messaging authorization and authentication).  Before the message is forwarded to the receiver, Facade performs decryption, authorization and authentication on it.</p><h5>Figure 7. MDP secure access to distributed components/services</h5><img src="JtFacade1.gif" width="580" /><p>The following are the components involved:</p><p>MessageCipher: component responsible for decrypting the input message and encrypting the reply message. This component can be configured to use a specific encryption scheme.</p><p>Component Registry: allows the system to register and look up components by ID.</p><p>AccessManager:  responsible for granting/denying access to remote components. It authorizes and authenticates each message received. If the access manager is unable to authenticate the message, it never reaches the receiver. </p><hr /><p><a href="#ibm-content">Back to top</a></p><h2>Framework Security </h2><p>MDP can deal with security challenges in a natural and intuitive manner. It provides end-to-end, non-repudiation and message-level security (as opposed to transport level security). It can also be used for selective encryption so that only sensitive portions of the message are encrypted. Well-known security mechanisms fit well with MDP. On the other hand, our model is not limited to a specific message format (XML, SOAP, etc.). Any message format and RESTful services can be accommodated. This includes proprietary and custom message formats.</p><p>Notice that under a messaging paradigm; most of the security aspects can be made
        transparent to message sender and receiver. For instance, sender and receiver
        don't need to be overly concerned as to whether or not security is being used and
        how it is being implemented. The framework provides the required security components and mechanisms ("plumbing").  Using our real-world analogy, in general you and your friend don't need to be concerned if the service provider is encrypting your conversation because of privacy and security considerations. The Jt framework also uses declarative security which avoids the need for error-prone security coding. Finally, custom security mechanisms can be accommodated based on specific requirements. </p><hr /><p><a href="#ibm-content">Back to top</a></p><h2>Asynchronous messaging,
       two-way messaging and multithreading</h2><p>Now consider your email or postal mailbox. Messages can be sent asynchronously and
        placed in a message queue or pile until you are ready to "process" them.  MDP is
        able to handle the complexities associated with and asynchronous messaging and
        multithreading. Framework components are able to execute in a separate/independent
        thread. This is a natural representation of the real world: each component
        (entity) is a self-contained unit able to execute independently for the rest of
        the system. Messages can be processed asynchronously using the component’s own independent thread.  This capability is implemented in the context of the Jt framework via a messaging queue. The component does not need to add separate logic to manage multithreading which is time consuming, complex and prone to error.</p><p>You can also decide to send a message back asynchronously establishing a two-way communication. MDP is able to model two-way asynchronous messaging in which components and applications communicate with each other. A combination of synchronous and asynchronous messaging is also possible. Consider the case where a co-worker or supervisor comes to check on progress while you are reading your email messages.</p><hr /><p><a href="#ibm-content">Back to top</a></p><h2>Performance,
       scalability and fault-tolerant considerations</h2><p>The MDP model is simple yet versatile and robust. It is able to handle complex
        issues associated with distributed applications.  MDP is compatible with common
        scalability and availability mechanisms (clustering, load balancing, failover, caching, etc). For instance, SOA and ESB applications based on MDP can run on a cluster of computers to improve reliability and availability. You also have the flexibility of choosing and combining protocols and technology while using MDP. You are not limited to a specific technology or protocol. Your choices will depend on the specific performance and availability requirements. </p><p>MDP can also be extended in a very natural way to provide fault-tolerant capabilities and techniques. The replicated state machine approach is a general method for implementing fault-tolerant systems by replicating components and coordinating their interaction via consensus algorithms. Framework components happen to behave like a state machine: input message, output message and component state are part of the model. </p><hr /><p><a href="#ibm-content">Back to top</a></p><h2>Enterprise Service Bus (ESB)
    capabilities</h2><p>The Jt Design Pattern Framework is also a messaging engine that provides Enterprise Service Bus (ESB) capabilities. It features transparent access to components running inside remote applications. Framework components (local and remote) are able to interchange messages securely. The Jt framework also allows you to connect heterogeneous applications regardless of the technologies being used, including JMS, Web Services, EJB, REST, HTTP, EJBs, etc. Design patterns implemented by the framework (messaging, adapters, remote proxies, strategy, facades, etc.) make this possible. The Jt Enterprise Service Bus implementation consists of the following main components: </p><ul><li>Enterprise Service Bus Adapter</li><li>JMS Adapters (point-to-point and publish-subscribe)</li><li>EJB Adapter</li><li>EJB Proxy</li><li>RESTful web services Adapter</li><li>Secure web services Adapter (Axis) </li><li>Axis Proxy </li><li>Message Cipher </li><li>Message Authenticator</li><li>Access Manager</li><li>Data Access Objects</li><li>Java Mail Adapter</li><li>XML/Component transformer</li></ul><p>These components can be interchangeably plugged into complex framework applications
      using the "lego/messaging" architecture. They can be assembled in a variety of configurations to meet specific business requirements. In this case, these building blocks have been put together to implement the Enterprise Service Bus (ESB) capabilities.</p><p>The framework ESB adapter connects applications to the Jt enterprise service bus.
        The ESB adapter can be configured to use any strategy for interchanging messages:  JMS, secure Axis Web services, EJBs, secure Restful web services, HTTP, etc. Custom/proprietary strategies and protocols may also be used. The ESB adapter and the other ESB components are also responsible for automatically converting the messages to the appropriate format/protocol.</p>












<h2>Resources</h2><h3>Learn</h3><ul><li> Download sources, documentation and project information from  the Jt Design Pattern Framework
 <a href="http://jt.dev.java.net/">project's page</a>.</li><li>
 "<a href="http://jt.dev.java.net/files/documents/5553/150311/designPatterns.pdf">Messaging Design Pattern and Pattern
 Implementation</a>":  Read about how the messaging design pattern is employed in the implementation of other design patterns including GoF, DAO and J2EE patterns.</li><li>
 "<a href="http://jt.dev.java.net/servlets/ProjectDocumentList">Complete Jt Code examples</a>":  Reliable File Transfer system based on ESB and web services.</li><li>
 "<a href="http://jt.dev.java.net/servlets/ProjectDocumentList">Complete Jt Code examples</a>":  Jt Wizard for automated generation of framework applications.</li><li> In the
<a href="http://www.ibm.com/developerworks/webservices">SOA and Web services area 
on developerWorks</a>, get the resources you need to advance your skills.</li><li> Browse the
<a href="http://www.ibm.com/developerworks/apps/SendTo?bookstore=safari">technology 
bookstore</a> for books on these and other technical topics. </li></ul><h3>Discuss</h3><ul><li> Check out
<a href="http://www.ibm.com/developerworks/blogs/">developerWorks
blogs</a> and get involved in the
<a href="http://www.ibm.com/developerworks/community">developerWorks community</a>. 
    </li></ul>


<h2>Comments</h2>
    
	
	


    



<p><a href="#">Close [x]</a></p>



 
<h2>developerWorks: Sign in</h2>




<p>Required fields are indicated with an asterisk (*).</p> 

<p>IBM ID:*<br /><a href="#">Need an IBM ID?</a> <br /><a href="/developerworks/dwwi/jsp/WSHelp.jsp?lang=en_US">Forgot your IBM ID?</a>   
</p> 
<p>Password:*<br /><a href="#">Forgot your password?</a><br /><a href="#">Change your password</a></p> 
<p>
	 Keep me signed in.
</p>
<p>By clicking <strong>Submit</strong>, you agree to the <a href="https://www.ibm.com/developerworks/community/terms/">developerWorks terms of use</a>.</p>

   <p> 
</p>


<hr />
<p>The first time you sign into developerWorks, a profile is created for you.  <strong>Information in your profile (your name, country/region, and company name) is displayed to the public and will accompany any content you post, unless you opt to hide your company name</strong>.  You may update your IBM account at any time.</p>
<p>All information submitted is secure.</p>









<p><a href="#">Close [x]</a></p>




<h2>Choose your display name</h2><br /><br />




<p>The first time you sign in to developerWorks, a profile is created for you, so you need to choose a display name.  Your display name accompanies the content you post on developerWorks.</p>
<p><strong>Please choose a display name between 3-31 characters</strong>. Your display name must be unique in the developerWorks community and should not be your email address for privacy reasons.</p>
<p>Required fields are indicated with an asterisk (*).</p> 

<p>Display name:*(Must be between 3 – 31 characters.)
</p>
<p>By clicking <strong>Submit</strong>, you agree to the <a href="https://www.ibm.com/developerworks/community/terms/">developerWorks terms of use</a>.</p>

   <p> 
</p>


<hr />
<p>All information submitted is secure.</p>




















<h2>Dig deeper into SOA and web services on developerWorks</h2>
<ul><li><a href="http://www.ibm.com/developerworks/webservices/">Overview</a></li><li><a href="http://www.ibm.com/developerworks/webservices/newto/">New to SOA and web services</a></li><li><a href="http://www.ibm.com/developerworks/webservices/library/">Technical library (tutorials and more)</a></li><li><a href="http://www.ibm.com/developerworks/webservices/find/downloads/">Downloads and products</a></li><li><a href="http://www.ibm.com/developerworks/webservices/find/projects/">Open source projects</a></li><li><a href="http://www.ibm.com/developerworks/webservices/standards/">Standards</a></li><li><a href="http://www.ibm.com/developerworks/webservices/find/events/">Events</a></li></ul>


    

<hr />
<ul><li><img height="60" width="60" src="//dw1.s81c.com/developerworks/i/sm-f-bluemixdev60.png" />
<h3><a href="https://developer.ibm.com/bluemix/">Bluemix Developers Community</a></h3>
<p>Get samples, articles, product docs, and community resources to help build, deploy, and manage your cloud apps.</p>
</li><li><img height="60" width="60" src="//www.ibm.com/developerworks/i/sm-f-dwnewsletters60.png" />
<h3><a href="http://ibmdeveloperworks.mkt6741.com/dWdWWeeklyNewsletterSubscriptionPage/">developerWorks Weekly Newsletter</a></h3>
<p>Keep up with the best and latest technical info to help you tackle your development challenges.</p></li><li><img height="60" width="60" src="//www.ibm.com/developerworks/i/sm-f-jazzhub2.png" />
<h3><a href="https://hub.jazz.net/?utm_source=developerWorks&amp;utm_medium=ad&amp;utm_campaign=dW+tiny+ad">DevOps Services</a></h3>
<p>Software development in the cloud.  Register today to create a project.</p></li><li><img height="60" width="60" src="//www.ibm.com/developerworks/i/sm-f-evaluationsoftware60.png" />
<h3><a href="http://www.ibm.com/developerworks/downloads/?ca=dti-tiles-evaluate">IBM evaluation software</a></h3>
<p>Evaluate IBM software and solutions, and transform challenges into opportunities.</p></li></ul>










	<hr /><p><a href="#ibm-content">Back to top</a></p>




static.content.url=http://www.ibm.com/developerworks/js/artrating/SITE_ID=1Zone=SOA and web servicesArticleID=492260ArticleTitle=Jt - Java Pattern Oriented Frameworkpublish-date=05272010



















</body></html>
